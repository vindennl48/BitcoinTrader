#include <iostream>
#include <math.h>
#include "../../mth.h"

typedef unsigned long int UINT;


#undef  THREADS
#define THREADS  (1<<8)   /* 256 */

// KERNELS
////////////////////////////////////////////////////////////////////////////////
template <typename ITR, typename N>
__global__
void kernel_prepare(double *sums, double *reacts, double *inputs){
  UINT tindex    = blockIdx.x*blockDim.x+threadIdx.x;
  if(tindex<N) sums[tindex] = inputs[ITR*N+tindex];
  reacts[tindex] = 1/(1+exp(-sums[tindex]))-.5;
  sums[tindex]   = 0;
};
__global__
void kernel_fire(double *sums, double *reacts, double *weights){
  volatile __shared__ double sdata[THREADS];
  volatile __shared__ double rdata[THREADS];
  volatile __shared__ double wdata[THREADS];

  UINT tid    = threadIdx.x;  /* opposing neuron */
  //UINT tindex = blockIdx.x*blockDim.x+threadIdx.x;
  UINT neuron = blockIdx.x;   /* this block's neuron */
  rdata[tid]  = reacts[tid];
  wdata[tid]  = weights[blockDim.x*tid+neuron];
  __syncthreads();

  if(tid != neuron)
    sdata[tid] = rdata[tid]*wdata[tid];
  else
    sdata[tid] = 0;
  __syncthreads();

  for(UINT s=blockDim.x/2; s>0; s>>=1){
    if(tid<s)
      sdata[tid]+=sdata[tid+s];
    __syncthreads();
  };

  if(tid==0) sums[blockIdx.x]=sdata[0];
};
////////////////////////////////////////////////////////////////////////////////


cArray<double> get_candles(int);


// MAIN
////////////////////////////////////////////////////////////////////////////////
int main(){

  cArray<double> temp = get_candles(50);

  loop(i, 50)
    nprint(temp.h[i] << ", ");
  PAUSE;

  const UINT num_neurons = THREADS;
  const UINT num_inputs  = 2000;

  cArray<double> sums   (num_neurons);
  cArray<double> reacts (num_neurons);
  cArray<double> weights(pow(num_neurons,2));
  cArray<double> inputs (num_inputs);

  loop(i, num_neurons){ sums.h[i] = .1; reacts.h[i] = 0; };
  loop(i, pow(num_neurons,2)) weights.h[i] = (double)100/(i+1);
  loop(i, num_inputs){
    
  };

  int start = mtime();
  sums.send(); reacts.send(); weights.send();
  loop(i, num_inputs){
    kernel_prepare<<<1,num_neurons>>><i,num_inputs>(sums.d, reacts.d, inputs.d);
    kernel_fire<<<num_neurons,num_neurons>>>(sums.d, reacts.d, weights.d);
  };
  sums.receive(); reacts.receive();
  int end = mtime();

  loop(i, num_neurons)
    print("sum: " << sums.h[i]);

  print("Time Elapsed: " << (start-end) << "ms, " << (double)(20*(start-end))/1000 << "sec/20");

  return 0;
}
////////////////////////////////////////////////////////////////////////////////


inline cArray<double>
get_candles(int num_candles){
  ifstream        if_candles;
  cArray<double>  candles_temp;
  cArray<double>  candles;

  if_candles.open("candles_raw.txt");
  string STRING; string::size_type sz;

  UINT x = 0;
  while(!candles_raw.eof()){
    try{
      getline(if_candles, STRING);
      try{ candles_temp.h[x] = stod(STRING, &sz); x+=1; } 
      catch(...){ print("Errir converting string to double."); x+=1; };
      STRING = "";
    }
    catch(...){
      print("candles_raw.txt has an uneven amount of lines!");
    };
  };
  UINT size = x;

  loop(i, num_candles)
    candles.h[i] = candles_temp.h[size-i];

  return candles;
};
