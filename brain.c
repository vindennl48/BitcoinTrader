#include <vector>
#include <string>
#include <math.h>
#include <ctime>
#include "brain.h"
#include "definitions.h"

using namespace std;


////////////////////////////////////////////////////////////////////////////////
// brain::create
////////////////////////////////////////////////////////////////////////////////
//
// Creates a Brain array
//
//   vector< vector<double> > [
//     [ index_id, sum, react, weights:[1,2,3,4,5] ], 
//     [ index_id, sum, react, weights:[1,2,3,4,5] ]
//   ]
//
////////////////////////////////////////////////////////////////////////////////
BRAIN brain::create(int num_neurons){

  BRAIN new_brain;

  loop(i, num_neurons){

    new_brain.push_back( neuron::create(i, num_neurons) );

  };

  return new_brain;

};



////////////////////////////////////////////////////////////////////////////////
// brain::get_str
////////////////////////////////////////////////////////////////////////////////
//
// Get string from brain to print
//
////////////////////////////////////////////////////////////////////////////////
string brain::get_str(BRAIN &b){

  string result;

  int len_brain = b.size();
  loop(i, len_brain){
     result += neuron::get_str(b.at(i)) + "\n";
  }

  return result;

};



////////////////////////////////////////////////////////////////////////////////
// brain::run
////////////////////////////////////////////////////////////////////////////////
//
// Operate brain through iterations
//
////////////////////////////////////////////////////////////////////////////////
void brain::run(BRAIN &b, int iterations){

  loop(h, iterations){
    int len_brain = b.size();

    loop(i, len_brain){
      neuron::prepare(b.at(i));
    };

    loop(i, len_brain){
      neuron::fire(b.at(i), b);
    };

  };

};



////////////////////////////////////////////////////////////////////////////////
// brain::input
////////////////////////////////////////////////////////////////////////////////
//
// Send input to neurons
//
////////////////////////////////////////////////////////////////////////////////
void brain::input(BRAIN &b, vector<double> &x){

  int len_x = x.size();
  loop(i, len_x){
    b.at(i).at(SUM) = x.at(i);
  };

};


////////////////////////////////////////////////////////////////////////////////
// brain::output
////////////////////////////////////////////////////////////////////////////////
//
// Get output from neurons
//
////////////////////////////////////////////////////////////////////////////////
vector<double> brain::output(BRAIN &b, int num_outputs){

  vector<double> result;

  int len_b = b.size()-1;
  loop(i, num_outputs){
    neuron::prepare(b.at(len_b - i));
    result.push_back( b.at(len_b - i).at(REACT) );
  };

  return result;

};



////////////////////////////////////////////////////////////////////////////////
// neuron::create
////////////////////////////////////////////////////////////////////////////////
//
// Creates a Neuron array:
//
//   vector<double> [ index_id, sum, react, weights:[1,2,3,4,5]]
//
////////////////////////////////////////////////////////////////////////////////
NEURON neuron::create(double index_id, int length){

  NEURON n = {
    index_id,  // id number of neuron in brain
    0,         // sum
    0          // react
               // the rest is weights
  };

  loop(i,length){
    // range from -100 to +100
    n.push_back( (rand()%200)-100 );
  };

  return n;

};



////////////////////////////////////////////////////////////////////////////////
// neuron::reset_weights
////////////////////////////////////////////////////////////////////////////////
//
// Resets weights in Neuron
//
////////////////////////////////////////////////////////////////////////////////
void neuron::reset_weights(NEURON &n){

  double index_id = n.at(0);
  int    n_length = n.size() - 3;
  NEURON new_n = { index_id, 0, 0 };

  loop(i,n_length){
    new_n.push_back( (rand()%200)-100 );
  };

  n = new_n;

};



////////////////////////////////////////////////////////////////////////////////
// neuron::fire
////////////////////////////////////////////////////////////////////////////////
//
// Fire Neuron:
//
//   vector n: neuron
//   vector b: brain
//
////////////////////////////////////////////////////////////////////////////////
void neuron::fire(NEURON &n, BRAIN &b){

  int len_weights = n.size() - 3;

  if(n.at(REACT) != 0){
    loop(i,len_weights){

      if(int(n.at(INDEX_ID)) != i){
        // Neuron Sum   |  React Val   | Weight
        b.at(i).at(SUM) += n.at(REACT) * n.at(i+3);
      };

    };
  };

};



////////////////////////////////////////////////////////////////////////////////
// neuron::prepare
////////////////////////////////////////////////////////////////////////////////
//
// Prepare Neuron
//
////////////////////////////////////////////////////////////////////////////////
void neuron::prepare(NEURON &n){

  n.at(REACT) = round(1/(1+exp(-n.at(SUM))),4);
  n.at(SUM)   = 0;

};



////////////////////////////////////////////////////////////////////////////////
// neuron::get_str
////////////////////////////////////////////////////////////////////////////////
//
// Turn Neuron into printable string
//
////////////////////////////////////////////////////////////////////////////////
string neuron::get_str(NEURON &n){

  string result = "";

  result +=  "Neuron: " + to_string(int(n.at(INDEX_ID)));
  result +=   ", Sum: " + dbl_to_s(n.at(SUM  ),4);
  result += ", React: " + dbl_to_s(n.at(REACT),4);
  return result;

};



////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// int main() {
//   srand(1);
//   clock_t start, end;
// 
//   vector< BRAIN > barray;
// 
//   loop(i, 20){
//     barray.push_back(brain::create(75));
//   };
// 
// 
//   start = clock();
//   print("start");
//   loop(i,20){
//     loop(j,25){
//       brain::run(barray.at(i), 2);
//     };
//   };
//   end = clock();
//   print("end");
// 
//   print(brain::get_str(barray.at(0)));
//   print("Elapsed Time: " << (end-start) / (double)(CLOCKS_PER_SEC) << "sec");
// 
//   return 0;
// };




